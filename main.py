
import ctypes

def Crc32(buf, len): #- определяем функцию с именем Crc32, которая принимает два аргумента: buf - массив байтов, и len - длину этого массива.
    crc_table = (ctypes.c_uint32 * 256)() #- создаем массив из 256 элементов типа c_uint32, который будет использоваться для хранения заранее вычисленных значений CRC32.
    crc = ctypes.c_uint32(0xFFFFFFFF) # инициализируем переменную crc значением 0xFFFFFFFF, которое является начальным значением для вычисления CRC32
    for i in range(256): # запускаем цикл от 0 до 255, чтобы заполнить массив crc_table заранее вычисленными значениями CRC32.
        crc = ctypes.c_uint32(i) #v- инициализируем переменную crc текущим значением i.
        for j in range(8):# - запускаем вложенный цикл от 0 до 7, чтобы вычислить значение CRC32 для текущего значения crc.
        
        # вычисляем новое значение crc на основе предыдущего значения и таблицы значений.
            crc = ctypes.c_uint32((crc.value >> 1) ^ 0xEDB88320 if crc.value & 1 else crc.value >> 1)
        crc_table[i] = crc.value# сохраняем вычисленное значение CRC32 в массив crc_table.
    while len: # - запускаем цикл, который будет вычислять CRC32 для каждого байта в массиве buf.
        crc = ctypes.c_uint32(crc_table[(crc.value ^ buf[0]) & 0xFF] ^ (crc.value >> 8)) 
        # - вычисляем новое значение crc на основе предыдущего значения, текущего байта из массива buf и таблицы значений.
        buf = buf[1:] # - удаляем первый элемент из массива buf.
        len -= 1 # - уменьшаем счетчик длины на 1.
    return ctypes.c_uint32(crc.value ^ 0xFFFFFFFF).value
    #возвращаем итоговое значение CRC32, которое получается путем инвертирования битов результата и применения операции XOR с 0xFFFFFFFF.



#         xor     eax,eax
# calc_crc32:
#         lodsb                   ; Получить следующий символ строки
#         mov     ebx,edx         ; Скопировать текущее значение CRC32
#         and     ebx,0FFh
#         xor     bl,al           ; XOR с текущим символом блока данных
 
#         shl     ebx,2           ; Вычисление смещения нужного dword в таблице
#         shr     edx,8
#         and     edx,0FFFFFFh
#         xor     edx,[crc32table+ebx] ; XOR CRC32 со значением из таблицы
 
#         loop    calc_crc32      ; Перейти к следующему символу
 
#         mov     eax,edx         ; В регистре EAX записана CRC32 строки
 
#         ; Если дальнейшая обработка не требуется, то проXORить CRC32
#         ; для завершения расчетов
#         cmp     [dFlag],TRUE
#         jne     @f
#         xor     eax,-1